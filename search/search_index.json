{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheshire","text":"<p>Cheshire is a minimal Linux-capable host platform built around the RISC-V CVA6 core. Its goal is to provide a lightweight, configurable, autonomously booting host to systems that need one, from minimal Linux-capable SoCs to manycore compute accelerators.</p> <p>Cheshire is developed as part of the PULP project, a joint effort between ETH Zurich and the University of Bologna.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>To learn how to build and use Cheshire, see Getting Started.</li> <li>To learn about available simulation, FPGA, and ASIC targets, see Targets.</li> <li>For detailed information on Cheshire's inner workings, consult the User Manual.</li> </ul> <p>If you are impatient and have all needed dependencies, you can run <code>make all</code>, then start QuestaSim in <code>target/sim/vsim</code> and run:</p> <pre><code>set BINARY ../../../sw/tests/helloworld.spm.elf\nsource compile.tcl\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Unless specified otherwise in the respective file headers, all code checked into this repository is made available under a permissive license. All hardware sources and tool scripts are licensed under the Solderpad Hardware License 0.51 (see <code>LICENSE</code>) with the exception of generated register file code (e.g. <code>hw/regs/*.sv</code>), which is generated by a fork of lowRISC's <code>regtool</code> and licensed under Apache 2.0. All software sources are licensed under Apache 2.0.</p>"},{"location":"#publication","title":"Publication","text":"<p>If you use Cheshire in your work, you can cite us:</p> <pre><code>@misc{ottaviano2023cheshire,\n      title         = {Cheshire: A Lightweight, Linux-Capable RISC-V Host\n                       Platform for Domain-Specific Accelerator Plug-In},\n      author        = {Alessandro Ottaviano and Thomas Benz and\n                       Paul Scheffler and Luca Benini},\n      year          = {2023},\n      eprint        = {2305.04760},\n      archivePrefix = {arXiv},\n      primaryClass  = {cs.AR}\n}\n</code></pre>"},{"location":"gs/","title":"Getting Started","text":"<p>We first discuss the Cheshire's project structure, its dependencies, and how to build it.</p>"},{"location":"gs/#repository-structure","title":"Repository structure","text":"<p>The project is structured as follows:</p> Directory Description Documentation <code>hw</code> Hardware sources as SystemVerilog RTL Architecture <code>sw</code> Software stack, build setup, and tests Software <code>target</code> Simulation, FPGA, and ASIC target setups Targets <code>util</code> Utility scripts <code>doc</code> Documentation Home"},{"location":"gs/#dependencies","title":"Dependencies","text":"<p>To build Cheshire, you will need:</p> <ul> <li>GNU Make <code>&gt;= 3.82</code></li> <li>Bender <code>&gt;= 0.27.1</code></li> <li>Python <code>&gt;= 3.9</code></li> <li>RISCV GCC <code>&gt;= 11.2.0</code></li> <li>Python packages in <code>requirements.txt</code></li> </ul> <p>Depending on your desired target, additional dependencies may be needed.</p>"},{"location":"gs/#building-cheshire","title":"Building Cheshire","text":"<p>To build different parts of Cheshire, run <code>make</code> followed by these targets:</p> <ul> <li><code>hw-all</code>: generated hardware, including IPs and boot ROM</li> <li><code>sw-all</code>: software running on our hardware</li> <li><code>sim-all</code>(\u2020): scripts and external models for simulation</li> <li><code>xilinx-all</code>: scripts for Xilinx FPGA implementation</li> </ul> <p>\u2020 <code>sim-all</code> will download externally provided peripheral simulation models, some proprietary and with non-free license terms, from their publically accessible sources; see <code>Makefile</code> for details. By running <code>sim-all</code> or the default target <code>all</code>, you accept this.</p> <p>Running <code>hw-all</code> is required at least once to correctly configure IPs we depend on. On reconfiguring any generated hardware or changing IP versions, <code>hw-all</code> should be rerun.</p> <p>To run all build targets above (\u2020):</p> <pre><code>make all\n</code></pre> <p>The following additional targets are not invoked by the above, but also available:</p> <ul> <li><code>bootrom-all</code>: Rebuilds the boot ROM. This is not done by default as reproducible builds (as checked by CI) can only be guaranteed for fixed compiler versions.</li> <li><code>nonfree-init</code>: Clones our internal repository with nonfree resources we cannot release, including our internal CI. This is not necessary to use Cheshire.</li> <li><code>clean-deps</code>: Removes checked-out bender dependencies and submodules. This is useful if references to dependencies are updated.</li> </ul>"},{"location":"gs/#targets","title":"Targets","text":"<p>A target is an end use for Cheshire. Each target requires different steps from here; read the page for your desired target in the following Targets chapter.</p>"},{"location":"tg/","title":"Targets","text":"<p>A target refers to an end use of Cheshire. This could be a simulation setup, an FPGA or ASIC implementation, or the integration into other SoCs.</p> <p>Target setups can either be included in this repository or live in an external repository and use Cheshire as a dependency.</p>"},{"location":"tg/#included-targets","title":"Included Targets","text":"<p>Included target setups live in the <code>target</code> directory. The associated make targets <code>&lt;target&gt;-all</code>  set up necessary resources and scripts before use.</p> <p>Each included target has a documentation page in this chapter:</p> <ul> <li>Simulation</li> <li>Xilinx FPGAs</li> </ul>"},{"location":"tg/#external-targets","title":"External Targets","text":"<p>For integration into other SoCs, Cheshire may be included either as a Bender dependency or Git submodule. For further information and best pratices, see SoC Integration.</p>"},{"location":"tg/integr/","title":"SoC Integration","text":"<p>Cheshire is designed to be highly configurable and provide host and interconnect infrastructure for systems on various scales. Examples of SoCs integrating Cheshire as a host are:</p> <ul> <li>Iguana, an minimal end-to-end open-source Linux-capable SoC built with open tools.</li> <li>Carfield, a mixed-criticality SoC targeting the automotive domain.</li> </ul>"},{"location":"tg/integr/#using-cheshire-in-your-project","title":"Using Cheshire In Your Project","text":"<p>As for internal targets, Cheshire must be built before use in external projects. We aim to simplify this as much as possible with a portable make fragment.</p> <p>If you use GNU Make to build your project and Bender to handle dependencies, you can include the Cheshire build system into your own makefile with:</p> <pre><code>include $(shell bender path cheshire)/cheshire.mk\n</code></pre> <p>All of Cheshire's build targets are now available with the prefix <code>chs-</code>. Alternatively, the variables <code>CHS_*</code> provide the non-phony targets built by each of these targets.</p> <p>You can leverage this to ensure your Cheshire build is up to date and rebuild hardware and software whenever necessary. You can change the default value of any build parameter, replace source files to adapt Cheshire, or reuse parts of its build system, such as the software stack or the register and ROM generators.</p>"},{"location":"tg/integr/#instantiating-cheshire","title":"Instantiating Cheshire","text":"<p>Almost all features of Cheshire can be included, excluded, or scaled through parameterization. We impose an internal memory map and reasonable constraints on all parameters, but within these constraints, Cheshire can scale to fit numerous scenarios.</p> <p>We provide a SystemVerilog macros header in <code>hw/include/cheshire/typedef.svh</code> that simplifies defining necessary interface types for Cheshire. To define a configuration struct for Cheshire, we recommend defining a function in a system package that starts from the default configuration <code>DefaultCfg</code> in <code>cheshire_pkg</code> and changes only necessary parameters.</p> <p>Unused inputs and inputs of zero effective width should be tied so as to initiate data transfers or handshakes (usually <code>'0</code>).</p> <p>A minimal clean instantiation would look as follows:</p> <pre><code>`include \"cheshire/typedef.svh\"\n\n// Define function to derive configuration from defaults.\n// This could also (preferrably) be done in a system package.\nfunction automatic cheshire_pkg::cheshire_cfg_t gen_cheshire_cfg();\ncheshire_pkg::cheshire_cfg_t ret = cheshire_pkg::DefaultCfg;\n// Make overriding changes. Here, we add two AXI manager ports\nret.AxiExtNumMst = 2;\nreturn ret;\nendfunction\n\nlocalparam cheshire_cfg_t CheshireCfg = gen_cheshire_cfg();\n\n// Generate interface types prefixed by `csh_` from our configuration.\n`CHESHIRE_TYPEDEF_ALL(csh_, CheshireCfg)\n\n// Instantiate Cheshire with our configuration and interface types.\ncheshire_soc #(\n.Cfg                ( CheshireCfg ),\n.ExtHartinfo        ( '0 ), // Tie iff there are no external harts.\n.axi_ext_llc_req_t  ( csh_axi_llc_req_t ),\n.axi_ext_llc_rsp_t  ( csh_axi_llc_rsp_t ),\n.axi_ext_mst_req_t  ( csh_axi_mst_req_t ),\n.axi_ext_mst_rsp_t  ( csh_axi_mst_rsp_t ),\n.axi_ext_slv_req_t  ( csh_axi_slv_req_t ),\n.axi_ext_slv_rsp_t  ( csh_axi_slv_rsp_t ),\n.reg_ext_req_t      ( csh_reg_req_t ),\n.reg_ext_rsp_t      ( csh_reg_rsp_t )\n) dut (\n// ... IOs here ...\n);\n</code></pre>"},{"location":"tg/integr/#verifying-cheshire-in-system","title":"Verifying Cheshire In-System","text":"<p>To simplify the simulation and verification of Cheshire in other systems, we provide a monolithic block of verification IPs called <code>cheshire_vip</code>. This includes:</p> <ul> <li>ELF binary preloading tasks over JTAG, serial link, and UART.</li> <li>External AXI manager ports accessing the chip through the serial link.</li> <li>A UART receiver printing to standard output.</li> <li>Serial link and LLC subordinate memories.</li> <li>Preloadable I2C EEPROM and SPI NOR Flash models (used to simulate boot).</li> </ul> <p>Additionally, we provide a module <code>cheshire_vip_tristate</code> which adapts the unidirectional IO of this module to bidirectional IOs which may be interfaced with pads where necessary.</p>"},{"location":"tg/integr/#platform-rom","title":"Platform ROM","text":"<p>To set up boot-critical resources in the surrounding system (clock sources, IO pads, memories, PHYs, ...) or fork off execution from the built-in boot ROM, Cheshire can invoke an external Platform ROM before external interaction if configured accordingly; see Boot ROM.</p> <p>Note that a reference clock, sufficiently fast and stable system clock, correctly set-up IOs, and accessible scratchpad memory are required for Cheshire's built-in active boot modes.</p>"},{"location":"tg/sim/","title":"Simulation","text":"<p>This page describes how to simulate Cheshire to execute baremetal code. Please first read Getting Started to make sure to make sure have all dependencies and built the hardware, software, and simulation scripts.</p> <p>We currently provide working setups for:</p> <ul> <li>Questa Advanced Simulator (QuestaSim) <code>&gt;= 2022.3</code></li> </ul> <p>We plan on supporting more simulators in the future. If your situation requires it, simulating Cheshire on other setups should be straightforward.</p>"},{"location":"tg/sim/#testbench","title":"Testbench","text":"<p>We provide a SystemVerilog testbench for <code>cheshire_soc</code> running baremetal code. This code is either preloaded through simulated interface drivers or read from external memory models by the boot ROM and then executed, depending on how the  <code>PRELMODE</code> and <code>BOOTMODE</code> variables are set:</p> <code>BOOTMODE</code> <code>PRELMODE</code> Action 0 0 Preload through JTAG 0 1 Preload through serial link 0 2 Preload through UART 1-3 - Autonomous boot, see Boot ROM <p>Preloading boot modes expect an ELF executable to be passed through <code>BINARY</code>, while autonomous boot modes expect a disk image (GPT formatted or raw code) to be passed through <code>IMAGE</code>. For more information on how to build software for Cheshire and its boot process, see Software.</p> <p>For simulation of Cheshire in other designs, we provide the module <code>cheshire_vip</code> encapsulating all verification IPs and their interfaces. For details, see Verifying Cheshire In-System.</p>"},{"location":"tg/sim/#questasim","title":"QuestaSim","text":"<p>After building Cheshire, start QuestaSim in <code>target/sim/vsim</code> and run:</p> <pre><code># Preload `helloworld.spm.elf` through serial link\nset BINARY ../../../sw/tests/helloworld.spm.elf\nset BOOTMODE 0\nset PRELMODE 1\n\n# Compile design\nsource compile.tcl\n\n# Start and run simulation\nsource start.cheshire_soc.tcl\nrun -all\n</code></pre> <p>The design needs to be recompiled only when hardware is changed. The simulation can be restarted by re-sourcing <code>start.cheshire_soc.tcl</code>, allowing binary (or image) and load method changes beforehand.</p>"},{"location":"tg/xilinx/","title":"Xilinx FGPAs","text":"<p>This page describes how to map Cheshire on Xilinx FPGAs to execute baremetal code or boot CVA6 Linux. Please first read Getting Started to make sure have all dependencies and built the hardware, software, and Xilinx FPGA scripts. Additionally, for on-chip debugging you need:</p> <ul> <li>OpenOCD <code>&gt;= 0.10.0</code></li> </ul> <p>We currently provide working setups for:</p> <ul> <li>Digilent Genesys 2 with Vivado <code>&gt;= 2020.2</code></li> </ul> <p>We are working on support for more boards in the future.</p>"},{"location":"tg/xilinx/#implementation","title":"Implementation","text":"<p>Since the implementation steps and available features vary between boards, we provide instructions and document available features for each.</p>"},{"location":"tg/xilinx/#digilent-genesys-2","title":"Digilent Genesys 2","text":"<p>Generate the bitstream <code>target/xilinx/out/cheshire_top_xilinx.bit</code> by running:</p> <pre><code>make -C target/xilinx\n</code></pre> <p>Before flashing the bitstream to your device, take note of the position of onboard switches, which control important functionality:</p> Switch Function 1 .. 0 Boot mode; see Boot ROM 5 .. 2 Fan level; do not keep at 0 7 Test mode; leave at zero <p>The reset, JTAG TAP, UART, I2C, and VGA are all connected to their onboard logic or ports. The UART has no flow control. The microSD slot is connected to chip select 0 of the SPI host peripheral. Serial link and GPIOs are currently not available.</p>"},{"location":"tg/xilinx/#debugging-with-openocd","title":"Debugging with OpenOCD","text":"<p>To establish a debug bridge over JTAG, ensure the target is in a debuggable state (for example by resetting into the idle boot mode 0) and launch OpenOCD with:</p> <pre><code>openocd -f $(bender path ariane)/corev_apu/fpga/ariane.cfg\n</code></pre> <p>In another shell, launch a RISC-V GDB session attaching to OpenOCD:</p> <pre><code>riscv64-unknown-elf-gdb -ex \"target extended-remote localhost:3333\"\n</code></pre> <p>You can now interrupt (Ctrl+C), inspect, and repoint execution with GDB as usual. Note that resetting the board during debug sessions is not supported. If the debug session dies or you need to reset the board for another reason:</p> <ol> <li>Terminate GDB and OpenOCD</li> <li>Reset the board</li> <li>Relaunch OpenOCD, then GDB.</li> </ol>"},{"location":"tg/xilinx/#running-baremetal-code","title":"Running Baremetal Code","text":"<p>Baremetal code can be preloaded through JTAG using OpenOCD and GDB or loaded from an SD Card. In principle, other interfaces may also be used to boot if the board provides them, but no setups are available for this.</p> <p>First, connect to UART using a serial communication program like minicom:</p> <pre><code>minicom -cD /dev/ttyUSBX\n</code></pre> <p>Make sure that hardware flow control matches your board's setup (usually off).</p> <p>In the following examples, we will use the <code>helloworld</code> test. As in simulation, you can replace this with any baremetal program of your choosing or design; see Baremetal Programming.</p>"},{"location":"tg/xilinx/#jtag-preloading","title":"JTAG Preloading","text":"<p>Start a debug session in the project root and enter in GDB:</p> <pre><code>load sw/tests/helloworld.spm.elf\ncontinue\n</code></pre> <p>You should see <code>Hello World!</code> output printed on the UART.</p>"},{"location":"tg/xilinx/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>First, build an up-to-date a disk image for your desired binary. For <code>helloworld</code>:</p> <pre><code>make sw/tests/helloworld.gpt.bin\n</code></pre> <p>Then flash this image to an SD card (note that this requires root privileges):</p> <pre><code>sudo dd if=sw/tests/helloworld.gpt.bin of=/dev/&lt;sdcard&gt;\nsudo sgdisk -e /dev/&lt;sdcard&gt;\n</code></pre> <p>The second command only ensures correctness of the partition layout; it moves the secondary GPT header at the end of the minimally sized image to the end of your actual SD card.</p> <p>Insert your SD card and reset into boot mode 1. You should see a <code>Hello World!</code> UART output.</p>"},{"location":"tg/xilinx/#booting-linux","title":"Booting Linux","text":"<p>To boot Linux, we must load the OpenSBI firmware, which takes over M mode and launches the U-boot bootloader. U-boot then loads Linux. For more details, see Boot Flow.</p> <p>Clone the <code>cheshire</code> branch of CVA6 SDK and build the firmware (OpenSBI + U-boot) and Linux images (this will take about 30 minutes):</p> <pre><code>git submodule update --init --recursive sw/deps/cva6-sdk\nmake -C sw/deps/cva6-sdk images\n</code></pre> <p>In principle, we can boot Linux through JTAG by loading all images into memory, launching OpenSBI, and instructing U-boot to load the kernel directly from memory. Here, we focus on autonomous boot from SD card.</p> <p>In this case, OpenSBI is loaded by a regular baremetal program called the Zero-Stage Loader (ZSL). The boot ROM loads the ZSL from SD card, which then loads the device tree and firmware from other SD card partitions into memory and launches OpenSBI.</p> <p>To create a full Linux disk image from the ZSL, device tree, firmware, and Linux, run:</p> <pre><code>make sw/boot/linux.gpt.bin\n</code></pre> <p>Flash this image to an SD card as you did in the previous section, then insert the SD card and reset into boot mode 1. You should first see the ZSL print on the UART:</p> <p><pre><code> /\\___/\\       Boot mode:       1\n( o   o )      Real-time clock: ... Hz\n(  =^=  )      System clock:    ... Hz\n(        )     Read global ptr: 0x...\n(    P    )    Read pointer:    0x...\n(  U # L   )   Read argument:   0x...\n(    P      )\n(           ))))))))))\n</code></pre> You should then boot through OpenSBI, U-Boot, and Linux until you are dropped into a shell.</p>"},{"location":"um/","title":"User Manual","text":"<p>The user manual provides detailed reference information on Cheshire. It currently comprises the following chapters:</p> <ul> <li>Architecture: Describes the hardware design, features, and configuration of Cheshire.</li> <li>Software Stack: Describes how to run code on Cheshire and its Linux boot flow.</li> </ul>"},{"location":"um/arch/","title":"Architecture","text":"<p>Cheshire is highly configurable; available features and resources depend on its parameterization. The above block diagram depicts a fully-featured Cheshire SoC, which currently provides:</p> <ul> <li> <p>Cores:</p> <ul> <li>Up to 16 Linux-capable CVA6 cores with self-invalidation-based coherence</li> <li>A RISC-V debug module with JTAG transport</li> </ul> </li> <li> <p>Peripherals:</p> <ul> <li>Various standard IO interfaces (UART, I2C, SPI, and GPIOs)</li> <li>A boot ROM enabling boot from SD cards, SPI flash, or I2C EEPROM</li> <li>A VGA display controller with built-in DMA</li> <li>A fully-digital die-to-die serial link</li> <li>A high-throughput system DMA</li> </ul> </li> <li> <p>Interconnect:</p> <ul> <li>A last level cache (LLC) configurable as a scratchpad memory (SPM) per-way</li> <li>Up to 16 external AXI manager ports and 16 AXI and Regbus subordinate ports</li> <li>Per-manager traffic regulators for real-time applications</li> </ul> </li> <li> <p>Interrupts:</p> <ul> <li>Core-local (CLINT and CLIC) and platform (PLIC) interrupt controllers</li> <li>Dynamic interrupt routing from and to internal and external targets.</li> </ul> </li> </ul>"},{"location":"um/arch/#memory-map","title":"Memory Map","text":"<p>Cheshire's internal memory map is static. While device instantiation and layout may vary, each device is provided an address space of fixed location and size. For this, Cheshire reserves the address space from <code>0x0</code> to <code>0x2000_0000</code>, which is currently allocated as follows:</p> <p>Block</p> <p>Device</p> <p>Start</p> <p>Size</p> <p>Flags</p> <p>256K periphs @ AXI</p> <p>Debug ROM</p> <p><code>0x0000_0000</code></p> <p>256K</p> <p>E</p> <p>4K periphs @ AXI</p> <p>AXI DMA (Cfg)</p> <p><code>0x0100_0000</code></p> <p>4K</p> <p>256K periphs @ Reg</p> <p>Boot ROM</p> <p><code>0x0200_0000</code></p> <p>256K</p> <p>E</p> <p>CLINT</p> <p><code>0x0204_0000</code></p> <p>256K</p> <p>IRQ router</p> <p><code>0x0208_0000</code></p> <p>256K</p> <p>4K periphs @ Reg</p> <p>SoC Regs</p> <p><code>0x0300_0000</code></p> <p>4K</p> <p>LLC (Cfg)</p> <p><code>0x0300_1000</code></p> <p>4K</p> <p>UART</p> <p><code>0x0300_2000</code></p> <p>4K</p> <p>I2C</p> <p><code>0x0300_3000</code></p> <p>4K</p> <p>SPI Host</p> <p><code>0x0300_4000</code></p> <p>4K</p> <p>GPIO</p> <p><code>0x0300_5000</code></p> <p>4K</p> <p>Serial Link (Cfg)</p> <p><code>0x0300_6000</code></p> <p>4K</p> <p>VGA (Cfg)</p> <p><code>0x0300_7000</code></p> <p>4K</p> <p>AXI RT (Cfg)</p> <p><code>0x0300_8000</code></p> <p>4K</p> <p>INTCs @ Reg</p> <p>PLIC</p> <p><code>0x0400_0000</code></p> <p>64M</p> <p>CLICs</p> <p><code>0x0800_0000</code></p> <p>64M</p> <p>LLC SPM @ AXI</p> <p>cached</p> <p><code>0x1000_0000</code></p> <p>64M</p> <p>CIE</p> <p>uncached</p> <p><code>0x1400_0000</code></p> <p>64M</p> <p>IE</p> <p>The flags are defined as follows:</p> <ul> <li>Cacheable: Accessed data may be cached in the L1 or LLC caches</li> <li>Idempotent: Multiple identical or composing accesses are equivalent to one access</li> <li>Executable: Data in this region may be executed.</li> </ul> <p>Additionally, Cheshire assumes the following parameterized layout for external resources:</p> <p>Block</p> <p>Start</p> <p>End</p> <p>Flags</p> <p>External on-chip</p> <p><code>0x2000_0000</code></p> <p><code>0x8000_0000</code></p> <p>?</p> <p>LLC out (DRAM)</p> <p><code>LlcOutRegionStart</code></p> <p><code>LlcOutRegionEnd</code></p> <p>CIE</p> <p>Serial Link</p> <p><code>SlinkRegionStart</code></p> <p><code>SlinkRegionEnd</code></p> <p>The external on-chip region is split into a region with full <code>CIE</code> flags and one without flags to minimize parameterization complexity. The parameters <code>Cva6ExtCieOnTop</code> and <code>Cva6ExtCieLength</code> control the order and partitioning of these two regions.</p> <p>The LLC out region must not collide with any other regions and defaults on starting at the lowest available address, <code>0x8000_0000</code>. The Serial Link region defaults on starting at <code>0x1_0000_0000</code> and configures the <code>SlinkTxAddrMask</code> and <code>SlinkTxAddrDomain</code> parameters to mirror the lower 32-bit space of another identical chip from this address base.</p>"},{"location":"um/arch/#devices-and-parameters","title":"Devices and Parameters","text":"<p>Except for external hart info and interface types (see Instantiating Cheshire), Cheshire is fully parameterized through the <code>Cfg</code> struct. We will first describe global parameters, then discuss the functionality and parameterization of each device individually.</p> <p>For defaults of any parameters, <code>cheshire_pkg::DefaultCfg</code> is the single source of truth. Note, however, that this does not mean <code>DefaultCfg</code> parameters are suitable for your system or usecase; please carefully consider and choose all parameters.</p> <p>The following global parameters control basic functionality and features and can be read by software in the SoC Registers:</p> Parameter Type / Range Description <code>RtcFreq</code> <code>word_bt</code> Frequency (Hz) configured for RTC <code>PlatformRom</code> <code>word_bt</code> Address of platform ROM; see Boot ROM <code>Bootrom</code> <code>bit</code> Whether boot ROM is available <code>Llc</code> <code>bit</code> Whether LLC is available <code>Uart</code> <code>bit</code> Whether UART is available <code>I2c</code> <code>bit</code> Whether I2C host is available <code>SpiHost</code> <code>bit</code> Whether SPI is available <code>Gpio</code> <code>bit</code> Whether GPIO is available <code>Dma</code> <code>bit</code> Whether DMA is available <code>SerialLink</code> <code>bit</code> Whether serial link is available <code>Vga</code> <code>bit</code> Whether VGA is available <code>AxiRt</code> <code>bit</code> Whether AXI RT is available <code>Clic</code> <code>bit</code> Whether CLIC is available <code>IrqRouter</code> <code>bit</code> Whether IRQ Router is available"},{"location":"um/arch/#cva6-cores","title":"CVA6 Cores","text":"Parameter Type / Range Description <code>NumCores</code> <code>1..15</code> Number of instantiated CVA6 cores"},{"location":"um/arch/#interconnect","title":"Interconnect","text":""},{"location":"um/arch/#boot-rom","title":"Boot ROM","text":""},{"location":"um/sw/","title":"Software","text":""},{"location":"um/sw/#baremetal-programming","title":"Baremetal programming","text":""},{"location":"um/sw/#boot-flow","title":"Boot Flow","text":""},{"location":"um/sw/#linux","title":"Linux","text":""}]}